/** @file   syscall_thread.c
 *
 *  @brief  thread syscall implementation for lab 4
 *  @note   Not for public release, do not share
 *
 *  @date   last modified 14 October 2022
 *  @author CMU 14-642
**/

#include <arm.h>
#include <mpu.h>
#include <printk.h>
#include <syscall.h>
#include <syscall_mutex.h>
#include <syscall_thread.h>
#include <unistd.h>
#include <timer.h>
#include<i2c.h>
#include<gpio.h>
#include<adc.h>
#include<pix.h>

/** @brief      Initial XPSR value, all 0s except thumb bit. */
#define XPSR_INIT 0x1000000

/** @brief Return code to return to user mode with user stack.*/
#define LR_RETURN_TO_USER_PSP 0xFFFFFFFD

extern uint32_t* __thread_k_stacks_base; // 0x20018000
extern uint32_t* __thread_k_stacks_limit; // 0x20010000
extern uint32_t* __thread_u_stacks_base; // 0x20010000
extern uint32_t* __thread_u_stacks_limit; // 0x20008000
extern char* __psp_stack_limit;
extern char* __msp_stack_limit;


/** @brief thread stack region limits */
//extern char __thread_u_stacks_limit, __thread_k_stacks_limit, __thread_k_stacks_base, __thread_u_stacks_base;

/** @brief precomputed values for UB test */
float ub_table[] = {
    0.000, 1.000, .8284, .7798, .7568,
     .7435, .7348, .7286, .7241, .7205,
     .7177, .7155, .7136, .7119, .7106,
     .7094, .7083, .7075, .7066, .7059,
     .7052, .7047, .7042, .7037, .7033,
     .7028, .7025, .7021, .7018, .7015,
     .7012, .7009
};

tcb_t TCB[16]; // array of 16 TCBs
kmutex_t MU[32]; // array of 32 mutexes
int last_mutex=0;

uint32_t eachThread;
// TCB 0 is main thread
// TCB 15 is the idle thread


// global tracker to track position in tcb
tcb_t* idle_tcb_pointers[16] = {0}; // pointer to the TCBs
// static int threadsCreated = -1;
static uint8_t totalThreads = 1;
uint32_t max_threads_from_user = 0;
uint32_t max_mutexes = 0;
// uint32_t systemTime = 0; //global system time counter
volatile uint32_t currentRunningThreadID = 0;
volatile uint32_t nextThreadID = 1;
uint32_t global_system_time = 0;
static uint32_t invocations = 0;
volatile uint32_t available_mutexes; // maximum number of mutexes available in the system
tcb_t* free_tcb_list = NULL;
kmutex_t* free_mutex_list; // free list containing mutexes
int kernel_mode_set = 0;
kmutex_t* global_mutex_list = NULL; // this is the global linked list storing all the mutexes in the system at the moment
// volatile kmutex_t * highest_priority_ceiling_m = NULL;

void default_idle();
void tcb_init(tcb_t* tcb, void* fn, void* vargp, uint32_t priority, uint32_t C, uint32_t T);
void append_tcb_list(tcb_t** start, tcb_t* new_tcb);
tcb_t* get_first_tcb(tcb_t** start);
void thread_kill_working();
void default_idle_helper();
void print_tcb(tcb_t* tcb_list);

/**
 * 
 * @brief This function is used to handle the interrupts which are generated by the systick timer
 * We perform the necessary state changes and then pend the pend SV which will take care of the
 * scheduling of the threads.
 * 
 * @param[in] none
 * 
 * @return does not return any value 
 * 
 **/


void systick_c_handler() {
    ++global_system_time; // increment global system time counter
    //printk("systick is working\n"); 
    pend_pendsv();

    for(int i = 1; i < 15; i++) {
        if(TCB[i].state != STOPPED) {
            if(((TCB[i].state == RUNNING)) || ((global_system_time != 0) && ((global_system_time % (TCB[i].T)) == 0))) {
                TCB[i].state = RUNNABLE;
        }
        }
    }

        TCB[currentRunningThreadID].execution_time++;
        // TCB[currentRunningThreadID].time_since_scheduler_start += TCB[currentRunningThreadID].execution_time;
        TCB[currentRunningThreadID].time_since_scheduler_start++;


    // update the status of the other tasks in the system
    return;
}

/**
 * 
 * This is the pendsv C handler which is going to take care of scheduling the next highest prio 
 * thread ID in the system. This accepts a pointer to the msp of the task which is stored in the 
 * stack and it will be transferred into r0 in the asm handler before the control being passed
 * into this very c handler. This does the necessary scheduling and then passes control back into the 
 * pend the pendsv asm handler.
 * 
 * @param[in] pointer to the msp
 * 
 * @return does not return 
 * 
 **/

void *pendsv_c_handler(void *msp){
    // in Systick handler, the next thread to be scheduled will be updated
    // check for that thread and schedule it here 

    // breakpoint();
    clear_pendsv();

    msp_stack_frame_t* ptr = (msp_stack_frame_t*)msp;

    // we are going to run the RMS scheduler 
    nextThreadID = RMS(); // RMS choice - returns with min period
    
    if (nextThreadID == 0) {
      // stop systick timer here
	systick_stop();
    }


    if((nextThreadID == currentRunningThreadID) && (TCB[currentRunningThreadID].state != BLOCKED) && (TCB[currentRunningThreadID].state != STOPPED)){
        // return the same msp
        TCB[currentRunningThreadID].state = RUNNING;
        // printk("Scheduling thread %lu\n", currentRunningThreadID);
        return msp;
    }

    // if there are no threads left to run in the pool
    if(currentRunningThreadID != nextThreadID) {

        
        // breakpoint();
        // means a different thread needs to be scheduled, save the context

        TCB[currentRunningThreadID].msp = ptr; // save the ptr
            
        TCB[currentRunningThreadID].svc_status = get_svc_status();

        uint8_t size = mm_log2ceil_size(eachThread);
        if (nextThreadID == 0) {
                size = mm_log2ceil_size(2048);
        }

        if(!kernel_mode_set) {
            if (currentRunningThreadID != 0) {
                mm_region_disable(USER_REGION);
            }
            if (mm_region_enable(USER_REGION, TCB[nextThreadID].user_stack_start, size, 0, 1) != 0) {
                 printk("Enable USER_REGION mem protection failed for thread id = %d\n", nextThreadID);
            }
        }
        if (currentRunningThreadID != 0) mm_region_disable(KERNEL_REGION);
        if (mm_region_enable(KERNEL_REGION, TCB[nextThreadID].kernel_stack_start, size, 0, 1) != 0) {
            printk("Enable KERNEL_REGION mem protection failed for thread id = %d\n", nextThreadID);
        }
            
    }
    
        // schedule the next thread
        TCB[nextThreadID].state = RUNNING;

        currentRunningThreadID = nextThreadID;

        set_svc_status(TCB[currentRunningThreadID].svc_status);

        //printk("Scheduling thread %lu\n", currentRunningThreadID);

        return (void*)TCB[nextThreadID].msp;
}

/**
 * 
 * 
 * @brief This is the default idle thread function which acts as a helper to call the wait_for_interrupt
 * function. When no threads remain in the system, then this idle thread is scheduled to run.
 * 
 * @params[in] none
 * 
 * @return does not return 
 * 
 **/

void default_idle_helper()
{
	//default_idle();
        while (1) {
 		wait_for_interrupt();
	}
}

/**
 * 
 * @brief This function is used to append an new mutex into the linked list of mutexes. It takes in
 * a pointer to the start of the list and also a pointer to the new mutex which must be added into
 * the linked list.
 * 
 * @param[in] pointer to the start of the linked list
 * @param[in] pointer to the mutex which needs to be added into the list
 * 
 * @return does not return 
 * 
 */

void append_mutex_list(kmutex_t** start, kmutex_t* new_mutex) {
    return;
        if (*start == NULL) {
                new_mutex->next = NULL;
                *start = new_mutex;
                return;
        }
        kmutex_t* node = *start;
        while (node->next != NULL) {
                node = node->next;
        }
        new_mutex->next = NULL;
        node->next = new_mutex;
}

/**
 * 
 * This function is used to append a new tcb into the linked list of TCBs that we maintain
 * in our kernel. This takes in a pointer to the start of the linked list and a pointer to the
 * new tcb which needs to be added.
 * 
 * @param[in] start of the tcb linked list
 * @param[in] pointer to the new tcb
 * 
 * @return does not return 
 * 
 **/


void append_tcb_list(tcb_t** start, tcb_t* new_tcb) {
	if (*start == NULL) {
        new_tcb->next = NULL;
		*start = new_tcb;
		return;
	}
    tcb_t* node = *start;
	while (node->next != NULL) {
        // printk("Node is %p\n", node);
		node = node->next;
	}

    if(new_tcb != node) {
    new_tcb->next = NULL;
    node->next = new_tcb;       
    }

}

/**
 * 
 * @brief This function is used to delete a tcb from the linked list of the TCBs. It also takes a pointer 
 * to the tcb which has to be deleted from the linked list. 
 * 
 * @params[in] pointer to the linked list from which the tcb has to be deleted
 * @params[in] pointer to the tcb which has to be deleted from the linked list
 * 
 * @return does not return 
 * 
 **/


void delete_tcb(tcb_t** start, tcb_t* del_tcb) {
	if (*start == NULL) {
		return;
	}
	// if del_tcb is first node in list
	if (*start == del_tcb) {
		*start = del_tcb->next;
        del_tcb->next = NULL;
		return;
	}
	tcb_t* node = *start;
        while (node->next != del_tcb) {
                node = node->next;
        }
        if (node != *start) {
        	node->next = del_tcb->next;
            del_tcb->next = NULL;
	}
}

/**
 * 
 * @brief This function is used to delete a mutex from the linked list of the mutexes. It also takes a pointer 
 * to the mutex which has to be deleted from the linked list. 
 * 
 * @params[in] pointer to the linked list from which the mutex has to be deleted
 * @params[in] pointer to the mutex which has to be deleted from the linked list
 * 
 * @return does not return 
 * 
 **/

void delete_mutex(kmutex_t** start, kmutex_t* del_mutex) {
    return;
	if (*start == NULL) {
		return;
	}
	// if del_tcb is first node in list
	if (*start == del_mutex) {
		*start = del_mutex->next;
        del_mutex->next = NULL;
		return;
	}
	kmutex_t* node = *start;
        while (node->next != del_mutex) {
                node = node->next;
        }
        if (node != *start) {
        	node->next = del_mutex->next;
            del_mutex->next = NULL;
	}
}

/**
 * 
 * @brief This is the function that is used to get the first free tcb from the linked list of TCBs.
 * It takes in a pointer to the tcb which needs to be deleted.
 * 
 * @params[in] pointer to tcb which has to be deleted from the list
 * 
 * @return returns a pointer to the tcb which has been fetched from the linked list
 * 
 **/

tcb_t* get_first_tcb(tcb_t** start) {
        tcb_t* first = *start;
	if (first == NULL) {
		printk("freelist is empty\n");
                return NULL;
        }
	if (first->next == NULL) {
                //printk("failed to make second tcb\n");
		*start = NULL;
        first->next = NULL;
        return first;
	}
	else {
		tcb_t* result = first;
		*start = first->next;
		result->next = NULL;
		return result;
	}
}

/**
 * 
 * @brief We maintain a free list of mutexes. This function loops through the free list
 * and returns the next free mutex.
 * 
 * @param[in] Pointer to the start of the linked list of mutexes from where we need to fetch the mutex
 * from 
 * .
 * 
 * @return Returns a pointer to the mutex which has been fetched from the linked list of the mutexes.
 * 
 */


kmutex_t* get_first_mutex(kmutex_t** start) {
        kmutex_t* first = *start;
        if (first == NULL) {
                printk("freelist of kmutex_t is empty\n");
                return NULL;
        }
        if (first->next == NULL) {
                //printk("failed to make second kmutex_t\n");
                *start = NULL;
                first->next = NULL;
                return first;
        }
        else {
                kmutex_t* result = first;
                *start = first->next;
                result->next = NULL;
                return result;
        }
}

/**
 * 
 * @brief This is the system call that is used to initialise the threads of the system. This takes
 * in all the details from the user like maximum threads to be created, size of the stack for each
 * thread, pointer to the idle function, mode of memory protection and the maximum mutexes needed.
 * 
 * @param[in] maximum number of threads of the system
 * @param[in] stack size for each thread
 * @param[in] pointer to the idle function
 * @param[in] memory protection - kernel only or per thread protection
 * @param[in] maximum number of mutexes in the system
 * 
 * @return -1 on failure and 0 on success
 * 
 **/


int sys_thread_init(uint32_t max_threads, uint32_t stack_size, void* idle_fn, mpu_mode memory_protection, uint32_t user_max_mutexes) {

   int interrupt_status = save_interrupt_state_and_disable();

   if (idle_fn == NULL) {
       idle_fn = &default_idle;
    }
    max_mutexes = user_max_mutexes;

    //enable the FPU to perform floating point operations
    enable_fpu();

    max_threads_from_user = max_threads;

    uint32_t log = mm_log2ceil_size(stack_size * 4);
    
    eachThread = (1U << log);

    uint32_t total_size = max_threads * eachThread;
    
    if((total_size > ((uint32_t)(&__thread_k_stacks_base) - (uint32_t)(&__thread_k_stacks_limit))) || 
        (total_size > ((uint32_t)(&__thread_u_stacks_base) - (uint32_t)(&__thread_u_stacks_limit)))) {
            printk("Stack is oversized bro, reduce it\n");
            restore_interrupt_state(interrupt_status);
            return -1;
        }
    // initialise the stack data structures
    
    if(!memory_protection) {
        kernel_mode_set = 1;
        mm_region_enable(USER_REGION, (void*)&__thread_u_stacks_limit, mm_log2ceil_size(32768), 0, 1);
    }

    // offset by stack_size * 4 cos we are using char* in pointer arithmetic not uint32_t* 
    
    uint32_t offset = eachThread;

    for(uint32_t i = 0; i < max_threads; i++) {
        // breakpoint();
        offset = (i * eachThread);
        TCB[i+1].kernel_stack_start = (void*)((char*)&__thread_k_stacks_limit + offset);
        TCB[i+1].kernel_stack_end = (void*)((char*)TCB[i+1].kernel_stack_start + eachThread);
        TCB[i+1].user_stack_start = (void*)((char*)&__thread_u_stacks_limit + offset);
        TCB[i+1].user_stack_end = (void*)((char*)TCB[i+1].user_stack_start + eachThread);
        TCB[i+1].fn = idle_fn;
        TCB[i+1].next = NULL;
      	append_tcb_list(&free_tcb_list, &TCB[i+1]); 
        TCB[i+1].state = STOPPED;
   } 
    // initialized free mutex list
    for (uint32_t i = 0; i < max_mutexes; i++) {
        MU[i].owner = NULL;
        MU[i].locked_by = __UINT32_MAX__;
        //append_mutex_list(&free_mutex_list, &MU[i]);
    }
    available_mutexes = max_mutexes;
    // main already has msp and psp initialized do not waste stack region for this
    TCB[0].msp->lr = (void*)LR_RETURN_TO_USER_PSP;
    TCB[0].prio = max_threads;
    TCB[0].msp->psp->xPSR = XPSR_INIT;
    TCB[0].svc_status = 0;
    TCB[0].kernel_stack_start = (void*)& __msp_stack_limit;
    TCB[0].user_stack_start = (void*)& __psp_stack_limit;

    // initialise idle thread TCB
    
    TCB[15].kernel_stack_end = &__thread_k_stacks_base;
    TCB[15].kernel_stack_start = (void*)((char*)TCB[15].kernel_stack_end - eachThread);

    TCB[15].user_stack_end = &__thread_u_stacks_base;
    TCB[15].user_stack_start = (void*)((char*)TCB[15].user_stack_end - eachThread);


    TCB[15].msp = (msp_stack_frame_t*)((char*)TCB[15].kernel_stack_end - sizeof(msp_stack_frame_t));
    TCB[15].msp->psp = (interrupt_stack_frame*)((char*)TCB[15].user_stack_end - sizeof(interrupt_stack_frame));
    // TCB[15].msp->psp->r0 = (uint32_t)vargp;

    TCB[15].msp->lr = (void*)LR_RETURN_TO_USER_PSP;
    TCB[15].prio = __UINT32_MAX__;
    TCB[15].msp->psp->xPSR = XPSR_INIT;
    TCB[15].svc_status = 0;
    TCB[15].C = __UINT32_MAX__;
    TCB[15].T = __UINT32_MAX__;
    TCB[15].state = RUNNABLE;
    TCB[15].running_time = 0;
    TCB[15].execution_time = 0;

    TCB[15].msp->psp->pc = idle_fn;
    TCB[15].msp->psp->lr = &default_idle;
    TCB[15].msp->psp->xPSR = XPSR_INIT;
    // setting everything to 0 so that all registers are clear when first init happens
    TCB[15].msp->psp->r1 = 0;
    TCB[15].msp->psp->r2 = 0;
    TCB[15].msp->psp->r3 = 0;
    TCB[15].msp->psp->r12 = 0;
    TCB[15].msp->r4 = 0;
    TCB[15].msp->r5 = 0;
    TCB[15].msp->r6 = 0;
    TCB[15].msp->r7 = 0;
    TCB[15].msp->r8 = 0;
    TCB[15].msp->r9 = 0;
    TCB[15].msp->r10 = 0;
    TCB[15].msp->r11 = 0;
    TCB[15].running_time = 0;
    TCB[15].svc_status = 0;
    TCB[15].execution_time = 0;
    TCB[15].static_priority = __UINT8_MAX__;
    TCB[15].time_since_scheduler_start = 0;
    
    restore_interrupt_state(interrupt_status);
    return 0;
}

/** @brief create a new thread as specified, if UB allows
 *
 *  @param fn       thread function pointer
 *  @param prio     thread priority, with 0 being highest
 *  @param C        execution time (scheduler ticks)
 *  @param T        task period (scheduler ticks)
 *  @param vargp    thread function argument
 *
 *  @return     0 for success, -1 for failure
 */

int sys_thread_create(void* fn, uint32_t priority, uint32_t C, uint32_t T, void* vargp) {

    // printk("Thread has priority %lu and Period %lu\n", priority, T);
   
    
    if(priority > 14) {
        printk("Prio cannot be greater than 15\n");
        return -1;
    }

    if(totalThreads > max_threads_from_user) {
        printk("Exceeded thread limit, %u, max threads is %u\n", totalThreads, max_threads_from_user);
        return -1;
    }

    // As soon as the user requests for a new thread, run a UB test for RMS to see if we can accept the thread
    if(UB_test_RMS(totalThreads, C, T) == -1) {
        printk("UB test failed\n");
        return -1;
    }
    //breakpoint();   
    // find empty TCB
    tcb_t* tcb = get_first_tcb(&free_tcb_list);
    //printk("Got tcb %p\n", tcb);
    if (tcb == NULL) {
        printk("No free TCB\n");
        return -1;
    } 
    tcb->next = NULL;
    tcb_init(tcb, fn, vargp, priority, C, T);
    totalThreads++;

    invocations++; // successfully created 

    tcb->state = RUNNABLE;

    // printk("Successfully created %u threads \n", invocations);
    return 0;
}

/**
 * 
 * @brief We maintain a linked list of all the TCBs. This function is used to initialise the linked 
 * list of the TCBs. It takes in the same paramters as sys_thread create and then assigns it to
 * the individual fields in the TCB.
 * 
 * @param fn       thread function pointer
 * @param prio     thread priority, with 0 being highest
 * @param C        execution time (scheduler ticks)
 * @param T        task period (scheduler ticks)
 * @param vargp    thread function argument
 * 
 * @return     0 for success, -1 for failure
 * 
 **/

void tcb_init(tcb_t* tcb, void* fn, void* vargp, uint32_t priority, uint32_t C, uint32_t T) {
    //breakpoint();
    tcb->msp = (msp_stack_frame_t*)((char*)tcb->kernel_stack_end - sizeof(msp_stack_frame_t));
    tcb->msp->lr = (void*)LR_RETURN_TO_USER_PSP;
    tcb->prio = priority;
    tcb->state = STOPPED;
    tcb->msp->psp = (interrupt_stack_frame*)((char*)tcb->user_stack_end - sizeof(interrupt_stack_frame));
    //printk("stack is %p \n", tcb->msp->psp);
    tcb->msp->psp->r0 = (uint32_t)(vargp);
    //printk("Argument in sys thread create is %s\n",tcb->msp->psp->r0);
    tcb->msp->psp->pc = fn;
    tcb->msp->psp->lr = (void*)&thread_kill_working;
    tcb->msp->psp->xPSR = XPSR_INIT;
    // setting everything to 0 so that all registers are clear when first init happens
    tcb->msp->psp->r1 = 0;
    tcb->msp->psp->r2 = 0;
    tcb->msp->psp->r3 = 0;
    tcb->msp->psp->r12 = 0;
    tcb->msp->r4 = 0;
    tcb->msp->r5 = 0;
    tcb->msp->r6 = 0;
    tcb->msp->r7 = 0;
    tcb->msp->r8 = 0;
    tcb->msp->r9 = 0;
    tcb->msp->r10 = 0;
    tcb->msp->r11 = 0;
    tcb->running_time = 0;
    tcb->C = C; // assign C
    tcb->T = T; // assign T
    tcb->svc_status = 0;
    tcb->execution_time = 0;
    tcb->static_priority = priority;
    tcb->dynamic_priority = priority;
    tcb->time_since_scheduler_start = 0;
    tcb->acquired_mutexes = NULL;
}

/** @brief tell the kernel to start running threads using Systick
 *  @note  returns only after all threads complete or are killed
 *
 *  @param frequency  frequncy of context switches in Hz
 *
 *  @return     0 for success, -1 for failure
 */

int sys_scheduler_start(uint32_t frequency) {
    systick_start(frequency);
    pend_pendsv();
    return 0;
}

/** @brief get the dynamic priority of the running thread 
 * 
 * @param no input paramters
 * 
 * @return returns the priority of the thread
 * 
 **/

uint32_t sys_get_priority() {
    return TCB[currentRunningThreadID].dynamic_priority;
}

/** @brief get the current time in ticks 
 * 
 * @param no input parameters
 * 
 * @return global system time which is mainted by the system
 * 
 **/

uint32_t sys_get_time() {
    return global_system_time;
}

/** @brief get the total elapsed time for the running thread 
 * 
 * @param no input parameters
 * 
 * @return value cumulative time that the thread has been executing
 * 
 **/

uint32_t sys_thread_time() {
    return TCB[currentRunningThreadID].time_since_scheduler_start;
}

/** @brief kill the running thread
 *
 *  @note  locks if main or idle thread is running or thread holds a mutex
 *
 *  @return does not return
 */

void print_tcb(tcb_t* tcb_list) {
    tcb_t* temp = tcb_list;

    while(temp != NULL) {
        printk("%p=>", temp);
        temp = temp->next;
    }
}

void sys_thread_kill() {
    printk("Killing the thread %lu\n", currentRunningThreadID);
    // tcb_t* free_tcb = NULL;
    if ((currentRunningThreadID != 0) && (currentRunningThreadID != 15)) {
        TCB[currentRunningThreadID].state = STOPPED;
        TCB[currentRunningThreadID].next = NULL;
        TCB[currentRunningThreadID].execution_time = 0;

        // free_tcb = &TCB[currentRunningThreadID];
        // free_tcb->next = NULL;
        append_tcb_list(&free_tcb_list, &TCB[currentRunningThreadID]);
        if(totalThreads > 1) {
            totalThreads--;
        }
    }
    
    // if currentRunningThreadID = 0, call sysexit
    if (currentRunningThreadID == 0) {
        // call sysexit here
        // systick_stop();
        sys_exit(0);
    }
    pend_pendsv();
    // if currentRunningThreadID = 15, call default_idle, psp->lr for idle thread is set to default_idle
}

/** @brief deschedule thread and wait until next turn 
 * 
 * @param no input parameters
 * 
 * @return no return value
 * 
 **/


void sys_wait_until_next_period() {
    // set the thread to waiting then immediately pend
    // a PendSV to run the scheduler. This will swap the thread out immediately, without waiting for the next SysTick.
    // make current thread waiting state
    // make scheduler wait till next interrupt
    TCB[currentRunningThreadID].state = WAITING;
    TCB[currentRunningThreadID].execution_time = 0;
    TCB[currentRunningThreadID].svc_status = 0;
    pend_pendsv(); 
    wait_for_interrupt();
}

/**
 * 
 * @brief This function is used to initialise  mutex in the system. It accepts the max prio
 * ceiling of the thread that will be using it. The kernel will not be doing any kind
 * of checking in this function.
 * 
 * @param in max prio of the thread that will use the mutex
 * 
 * @return pointer to the mutex on success and NULL on failure
 * 
 **/


kmutex_t* sys_mutex_init(uint32_t max_prio) {
    MU[last_mutex].locked_by = __UINT32_MAX__;
    MU[last_mutex].prio_ceil = max_prio;
    MU[last_mutex].owner = NULL;
    return &MU[last_mutex++];
}


kmutex_t* find_highest_priority_ceiling() {
    uint32_t res = __UINT32_MAX__;
    kmutex_t* m=NULL;
    // while(temp != NULL) {
    for(int i = 0 ; i < last_mutex; i ++)
    {
        kmutex_t* temp = &MU[i];
        if(temp->prio_ceil < res && temp->owner != NULL) {
            res = temp->prio_ceil;
            m=temp;
        }

        // temp = temp->next;
    }

    if(res!=__UINT32_MAX__)
        return m;
    else    
        return NULL;
}
/**
 * 
 * @brief this function is used to lock a mutex when a thread has to execute a critical section.
 * 
 * @param takes in a pointer to the mutex that the thread wants to lock
 * 
 * @return no return value
 * 
 **/


void sys_mutex_lock(kmutex_t* mutex) {

    uint32_t thread_holding_previous_lock;

    if(TCB[currentRunningThreadID].static_priority < mutex->prio_ceil) {
        // printk("You cannot acquire this mutex dear thread, you are of low priority.!\n");
        sys_thread_kill();
    }

    if (mutex->owner == &TCB[currentRunningThreadID]) {
        printk("WARNING (sys_mutex_lock): Lock already acquired by the same thread %lu\n", currentRunningThreadID - 1);
        return;
    }
     
        
        kmutex_t* highest_priority_ceiling_m = find_highest_priority_ceiling();

    

        while((highest_priority_ceiling_m!= NULL) 
        && (TCB[currentRunningThreadID].dynamic_priority >= highest_priority_ceiling_m->prio_ceil) 
        && (highest_priority_ceiling_m->owner != &TCB[currentRunningThreadID])
        ){
            // this means that the currentRunningThread has highest prio amongst all resources
            thread_holding_previous_lock = mutex->locked_by;
            
            TCB[currentRunningThreadID].state = BLOCKED; // prev holding task becomes BLOCKED now

            if(TCB[thread_holding_previous_lock].dynamic_priority > TCB[currentRunningThreadID].static_priority)
                TCB[thread_holding_previous_lock].dynamic_priority = TCB[currentRunningThreadID].static_priority;
            
            
            pend_pendsv();
            
            highest_priority_ceiling_m = find_highest_priority_ceiling();

        }        

    //printk("Got the lock(%p) by thread %lu\n",mutex, currentRunningThreadID);
    
    mutex->owner = &TCB[currentRunningThreadID];
    mutex->locked_by = currentRunningThreadID;

    return;
}

/**
 * 
 * @brief this function is used to unlock a mutex when a thread is done executing a critical section.
 * 
 * @param takes in a pointer to the mutex that the thread wants to unlock
 * 
 * @return no return value
 * 
 **/

void sys_mutex_unlock(kmutex_t* mutex) {
    if (mutex->owner == NULL) {
        printk("WARNING (sys_mutex_unlock): Mutex is free, cannot be unlocked again\n");
        // pend_pendsv();
    }
    else
        TCB[mutex->locked_by].dynamic_priority = TCB[mutex->locked_by].static_priority;


    // check in the mutex list

    // delete_mutex(&TCB[currentRunningThreadID].acquired_mutexes, mutex);
    mutex->next = NULL;

    //TODO : Now once a mutex has been released by a task, then should we wait for all the mutexes 
    // held by this task to be released? Or can we proceed with scheduling the next one?

    mutex->owner = NULL;
    mutex->locked_by = __UINT32_MAX__;

    //printk("Unlocked the lock(%p) by thread %lu\n",mutex, currentRunningThreadID);


    for(int i = 1; i <= 14; i++) {
        if(TCB[i].state == BLOCKED) {
            TCB[i].state = RUNNABLE;
        }
    }

    // TCB[currentRunningThreadID].dynamic_priority = TCB[currentRunningThreadID].static_priority;
    // pend_pendsv();
    //append_mutex_list(free_mutex_list, mutex);
}

/**
 * 
 * @brief RMS scheduler which is used to find the highest priority task based on the time period
 * of each task.
 * 
 * @param[in] none
 * 
 * @return returns the ID of the thread 
 * 
 **/

uint32_t RMS() {
    uint32_t stopped = 0;
    for(uint32_t i = 1; i <= max_threads_from_user; i++) {
        if (TCB[i].state == STOPPED) {
            stopped++;
	    continue;
        }
        // if ((global_system_time != 0) && ((global_system_time % (TCB[i].T)) == 0)) {
        //     // if (((global_system_time % (TCB[i].T)) == 0)) {
        // // if ((global_system_time != 0) && ((global_system_time % (TCB[i].T - 1)) == 0)) {
        //     // one edge case here is that, if currentThreadID just changed to waiting, but period has been
        //     // reached, then the state immediately changes to RUNNABLE
        //     TCB[i].state = RUNNABLE;
        // }
    }

    
   

    if((TCB[currentRunningThreadID].state != BLOCKED) && (TCB[currentRunningThreadID].state != STOPPED) &&
        ((TCB[currentRunningThreadID].execution_time >= TCB[currentRunningThreadID].C) 
            || (TCB[currentRunningThreadID].state == WAITING))) {
        // TODO : print a warning message if the thread is currently holding a mutex
        TCB[currentRunningThreadID].dynamic_priority = TCB[currentRunningThreadID].static_priority;
        TCB[currentRunningThreadID].state = WAITING;
        TCB[currentRunningThreadID].execution_time = 0;
    }


    if (stopped == max_threads_from_user) {
	// schedule main if all threads died
        return 0;
    } 

    // find the task with the least period
    uint32_t min_period = __UINT32_MAX__;
    uint32_t index = 15;


    for(uint32_t i = 1; i <= max_threads_from_user; i++) {
        // if((TCB[i].dynamic_priority < min_period) && (TCB[i].state == RUNNABLE)) {
        //     min_period = TCB[i].dynamic_priority;
        //     index = i;
        // }
        if( TCB[i].state == RUNNABLE && TCB[i].state != STOPPED) {
            if(TCB[i].dynamic_priority <= min_period){
                min_period = TCB[i].dynamic_priority;
                index = i;
            }
            else if(TCB[i].dynamic_priority == min_period && TCB[i].dynamic_priority != TCB[i].static_priority)
            {
                index = i;
            }

            
        }
    }

    // printk("The next highest priority task is %lu\n", index);

    return index;

}

/**
 * 
 * @brief Used to perform the UB test and outputs whether the task set is schedulable or not
 * 
 * @param[in] Number of threads in the system currently (includes the new thread to be scheduled)
 * @param[in] WCET of the task
 * @param[in] Time period of the task 
 * 
 * */

int UB_test_RMS(uint32_t no_threads, uint32_t C, uint32_t T) {
    // uint32_t index = no_threads - 1;

    if(no_threads == 0) {
        no_threads = 1;
    }

    float Ci = (float)C;
    float Ti = (float)T;

    if(no_threads == 1) {
        // first thread is being created 

        if((Ci / Ti) > ub_table[no_threads]) {
            return -1;
        }
    }

    float util = 0.0f;

    for(uint32_t i = 1; i < no_threads; i++) {
        util += (float)((float)(TCB[i].C) / (float)(TCB[i].T));
    }

    if((util + (Ci / Ti)) > ub_table[no_threads]) {
        return -1;
    }

    return 0;

}

/**
 * 
 * @brief This function is used to read the lux sensor. This is a system call which gets
 * called when the stub for the specific user function is pressed. 
 * 
 * @params[in] none
 * 
 * @return none
 * 
 */

void sys_read_lux() {
    // printk("entered read lux\n");

    uint8_t txbuffer1[3] = {0x00, 0x00, 0x00};

	int i2c;
	i2c = i2c_leader_write(txbuffer1, 3, 0x10);

	i2c_leader_stop();

	if(i2c == -1) {
		printk("Write failed\n");
	}

	uint8_t txbuffer2[1]= {0x04};

	i2c = i2c_leader_write(txbuffer2, 1, 0x10);

	if(i2c == -1) {
		printk("Write failed\n");
	}

	uint8_t rxbuffer[2] = {0};

	int i2c_ = i2c_leader_read(rxbuffer, 2, 0x10);

	i2c_leader_stop();
	if(i2c_ == -1) {
		printk("Read failed\n");
	}

	uint16_t result_ = 0;
    (void)result_;
    result_ = rxbuffer[0] | (rxbuffer[1] << 8);

    // printk("I read %d from lux\n", result_);
}

/**
 * 
 * @brief This function is used to read the microphone. This is a system call which gets
 * called when the stub for the specific user function is pressed. 
 * 
 * @params[in] none
 * 
 * @return none
 * 
 */

void sys_read_mic() {
    // printk("entered mic lux\n");
    adc_read_pin();
}

/**
 * 
 * @brief This function is system call which is used to glow the led. This is called
 * via a stub from the user space function.
 * 
 * @param[in] If the user gives 0 then the leds turn off. Else, then remain on.
 * 
 * @return none
 * 
 */

void sys_glow_led(int on) {
    glow_led(on);
}


/**
 * 
 * @brief This function is used to move the car forward. This is the system call that does
 * the propulsion. It calls another pwm helper function to actuate the motors.
 * 
 * @params[in] none
 * 
 * @return none
 * 
 */

void sys_move_forward(void) {
    pwm_actuate_forward();
}


/**
 * 
 * @brief This function is used to move the car backward. This is the system call that does
 * the propulsion. It calls another pwm helper function to actuate the motors.
 * 
 * @params[in] none
 * 
 * @return none
 * 
 */

void sys_move_backward(void) {

    pwm_actuate_backward();
}


/**
 * 
 * @brief This function is used to move the car left. This is the system call that does
 * the propulsion. It calls another pwm helper function to actuate the motors.
 * 
 * @params[in] none
 * 
 * @return none
 * 
 */

void sys_turn_left(void) {

    pwm_actuate_left();
}


/**
 * 
 * @brief This function is used to move the car right. This is the system call that does
 * the propulsion. It calls another pwm helper function to actuate the motors.
 * 
 * @params[in] none
 * 
 * @return none
 * 
 */

void sys_turn_right(void) {
    pwm_actuate_right();
}


/**
 * 
 * @brief This function is used to stop the car. It calls another pwm helper function to stop the motors.
 * 
 * @params[in] none
 * 
 * @return none
 * 
 */

void sys_stop_car(void) {
    pwm_stop();
}


