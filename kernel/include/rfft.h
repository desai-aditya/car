/** @file   rfft.h
 *
 *  @brief  constants, macros, prototypes for real FFT
 *  @note   Not for public release, do not share
 *
 *  @date   last modified 12 September 2022
 *  @author CMU 14-642
**/

#include <unistd.h>

#define FFT_SIZE 256
#define CFFT_LEN 128
#define BIT_REV_LEN 112  // length of bit reversal table

void rfft(int16_t *pIn, int16_t *pOut);
void rfft_abs(int16_t *pIn, int16_t *pOut, uint32_t len);

/**    
 * @brief lookup table for N=CFFT_LEN CFFT twiddle coefficients
 * @note  length is 3*N/2
 */
static const int16_t twiddleCoef[3 * CFFT_LEN / 2] = {
    0x7FFF, 0x0000, 0x7FD8, 0x0647, 0x7F62, 0x0C8B, 0x7E9D, 0x12C8,
    0x7D8A, 0x18F8, 0x7C29, 0x1F19, 0x7A7D, 0x2528, 0x7884, 0x2B1F,
    0x7641, 0x30FB, 0x73B5, 0x36BA, 0x70E2, 0x3C56, 0x6DCA, 0x41CE,
    0x6A6D, 0x471C, 0x66CF, 0x4C3F, 0x62F2, 0x5133, 0x5ED7, 0x55F5,
    0x5A82, 0x5A82, 0x55F5, 0x5ED7, 0x5133, 0x62F2, 0x4C3F, 0x66CF,
    0x471C, 0x6A6D, 0x41CE, 0x6DCA, 0x3C56, 0x70E2, 0x36BA, 0x73B5,
    0x30FB, 0x7641, 0x2B1F, 0x7884, 0x2528, 0x7A7D, 0x1F19, 0x7C29,
    0x18F8, 0x7D8A, 0x12C8, 0x7E9D, 0x0C8B, 0x7F62, 0x0647, 0x7FD8,
    0x0000, 0x7FFF, 0xF9B8, 0x7FD8, 0xF374, 0x7F62, 0xED37, 0x7E9D,
    0xE707, 0x7D8A, 0xE0E6, 0x7C29, 0xDAD7, 0x7A7D, 0xD4E0, 0x7884,
    0xCF04, 0x7641, 0xC945, 0x73B5, 0xC3A9, 0x70E2, 0xBE31, 0x6DCA,
    0xB8E3, 0x6A6D, 0xB3C0, 0x66CF, 0xAECC, 0x62F2, 0xAA0A, 0x5ED7,
    0xA57D, 0x5A82, 0xA128, 0x55F5, 0x9D0D, 0x5133, 0x9930, 0x4C3F,
    0x9592, 0x471C, 0x9235, 0x41CE, 0x8F1D, 0x3C56, 0x8C4A, 0x36BA,
    0x89BE, 0x30FB, 0x877B, 0x2B1F, 0x8582, 0x2528, 0x83D6, 0x1F19,
    0x8275, 0x18F8, 0x8162, 0x12C8, 0x809D, 0x0C8B, 0x8027, 0x0647,
    0x8000, 0x0000, 0x8027, 0xF9B8, 0x809D, 0xF374, 0x8162, 0xED37,
    0x8275, 0xE707, 0x83D6, 0xE0E6, 0x8582, 0xDAD7, 0x877B, 0xD4E0,
    0x89BE, 0xCF04, 0x8C4A, 0xC945, 0x8F1D, 0xC3A9, 0x9235, 0xBE31,
    0x9592, 0xB8E3, 0x9930, 0xB3C0, 0x9D0D, 0xAECC, 0xA128, 0xAA0A,
    0xA57D, 0xA57D, 0xAA0A, 0xA128, 0xAECC, 0x9D0D, 0xB3C0, 0x9930,
    0xB8E3, 0x9592, 0xBE31, 0x9235, 0xC3A9, 0x8F1D, 0xC945, 0x8C4A,
    0xCF04, 0x89BE, 0xD4E0, 0x877B, 0xDAD7, 0x8582, 0xE0E6, 0x83D6,
    0xE707, 0x8275, 0xED37, 0x8162, 0xF374, 0x809D, 0xF9B8, 0x8027
};

/**    
 * @brief lookup table for N=CFFT_LEN CFFT bit reversal
 */
static const uint16_t bitRevTable[BIT_REV_LEN] = {
     8, 512,  16, 256,  24, 768,  32, 128,  40, 640,  48, 384,  56, 896,  72, 576,  80, 320,  88, 832,
    96, 192, 104, 704, 112, 448, 120, 960, 136, 544, 144, 288, 152, 800, 168, 672, 176, 416, 184, 928, 
   200, 608, 208, 352, 216, 864, 232, 736, 240, 480, 248, 992, 264, 528, 280, 784, 296, 656, 304, 400, 
   312, 912, 328, 592, 344, 848, 360, 720, 368, 464, 376, 976, 392, 560, 408, 816, 424, 688, 440, 944, 
   456, 624, 472, 880, 488, 752, 504,1008, 536, 776, 552, 648, 568, 904, 600, 840, 616, 712, 632, 968,
   664, 808, 696, 936, 728, 872, 760,1000, 824, 920, 888, 984
};

/**    
 * twiddle coefficient table A for real FFT, N=FFT_SIZE
 */
static const int16_t __attribute__((aligned(4))) realCoefA[FFT_SIZE - 2] = {

    0x3e6e, 0xc005, 0x3cdc, 0xc014, 0x3b4b, 0xc02c, 0x39ba, 0xc04f,
    0x382a, 0xc07b, 0x369c, 0xc0b1, 0x350f, 0xc0f1, 0x3384, 0xc13b,
    0x31fa, 0xc18e, 0x3073, 0xc1eb, 0x2eee, 0xc251, 0x2d6c, 0xc2c1,
    0x2bed, 0xc33b, 0x2a70, 0xc3be, 0x28f7, 0xc44a, 0x2782, 0xc4df,
    0x2611, 0xc57e, 0x24a3, 0xc625, 0x233a, 0xc6d5, 0x21d5, 0xc78f,
    0x2074, 0xc850, 0x1f19, 0xc91b, 0x1dc3, 0xc9ee, 0x1c72, 0xcac9,
    0x1b26, 0xcbad, 0x19e0, 0xcc98, 0x18a0, 0xcd8c, 0x1766, 0xce87,
    0x1632, 0xcf8a, 0x1505, 0xd094, 0x13df, 0xd1a6, 0x12bf, 0xd2bf,
    0x11a6, 0xd3df, 0x1094, 0xd505, 0xf8a, 0xd632, 0xe87, 0xd766,
    0xd8c, 0xd8a0, 0xc98, 0xd9e0, 0xbad, 0xdb26, 0xac9, 0xdc72,
    0x9ee, 0xddc3, 0x91b, 0xdf19, 0x850, 0xe074, 0x78f, 0xe1d5,
    0x6d5, 0xe33a, 0x625, 0xe4a3, 0x57e, 0xe611, 0x4df, 0xe782,
    0x44a, 0xe8f7, 0x3be, 0xea70, 0x33b, 0xebed, 0x2c1, 0xed6c,
    0x251, 0xeeee, 0x1eb, 0xf073, 0x18e, 0xf1fa, 0x13b, 0xf384,
    0xf1, 0xf50f, 0xb1, 0xf69c, 0x7b, 0xf82a, 0x4f, 0xf9ba,
    0x2c, 0xfb4b, 0x14, 0xfcdc, 0x5, 0xfe6e, 0x0, 0x0,
    0x5, 0x192, 0x14, 0x324, 0x2c, 0x4b5, 0x4f, 0x646,
    0x7b, 0x7d6, 0xb1, 0x964, 0xf1, 0xaf1, 0x13b, 0xc7c,
    0x18e, 0xe06, 0x1eb, 0xf8d, 0x251, 0x1112, 0x2c1, 0x1294,
    0x33b, 0x1413, 0x3be, 0x1590, 0x44a, 0x1709, 0x4df, 0x187e,
    0x57e, 0x19ef, 0x625, 0x1b5d, 0x6d5, 0x1cc6, 0x78f, 0x1e2b,
    0x850, 0x1f8c, 0x91b, 0x20e7, 0x9ee, 0x223d, 0xac9, 0x238e,
    0xbad, 0x24da, 0xc98, 0x2620, 0xd8c, 0x2760, 0xe87, 0x289a,
    0xf8a, 0x29ce, 0x1094, 0x2afb, 0x11a6, 0x2c21, 0x12bf, 0x2d41,
    0x13df, 0x2e5a, 0x1505, 0x2f6c, 0x1632, 0x3076, 0x1766, 0x3179,
    0x18a0, 0x3274, 0x19e0, 0x3368, 0x1b26, 0x3453, 0x1c72, 0x3537,
    0x1dc3, 0x3612, 0x1f19, 0x36e5, 0x2074, 0x37b0, 0x21d5, 0x3871,
    0x233a, 0x392b, 0x24a3, 0x39db, 0x2611, 0x3a82, 0x2782, 0x3b21,
    0x28f7, 0x3bb6, 0x2a70, 0x3c42, 0x2bed, 0x3cc5, 0x2d6c, 0x3d3f,
    0x2eee, 0x3daf, 0x3073, 0x3e15, 0x31fa, 0x3e72, 0x3384, 0x3ec5,
    0x350f, 0x3f0f, 0x369c, 0x3f4f, 0x382a, 0x3f85, 0x39ba, 0x3fb1,
    0x3b4b, 0x3fd4, 0x3cdc, 0x3fec, 0x3e6e, 0x3ffb
};

/**    
 * twiddle coefficient table B for real FFT, N=FFT_SIZE
 */
static const int16_t __attribute__((aligned(4))) realCoefB[FFT_SIZE - 2] = {
    0x4192, 0x3ffb, 0x4324, 0x3fec, 0x44b5, 0x3fd4, 0x4646, 0x3fb1,
    0x47d6, 0x3f85, 0x4964, 0x3f4f, 0x4af1, 0x3f0f, 0x4c7c, 0x3ec5,
    0x4e06, 0x3e72, 0x4f8d, 0x3e15, 0x5112, 0x3daf, 0x5294, 0x3d3f,
    0x5413, 0x3cc5, 0x5590, 0x3c42, 0x5709, 0x3bb6, 0x587e, 0x3b21,
    0x59ef, 0x3a82, 0x5b5d, 0x39db, 0x5cc6, 0x392b, 0x5e2b, 0x3871,
    0x5f8c, 0x37b0, 0x60e7, 0x36e5, 0x623d, 0x3612, 0x638e, 0x3537,
    0x64da, 0x3453, 0x6620, 0x3368, 0x6760, 0x3274, 0x689a, 0x3179,
    0x69ce, 0x3076, 0x6afb, 0x2f6c, 0x6c21, 0x2e5a, 0x6d41, 0x2d41,
    0x6e5a, 0x2c21, 0x6f6c, 0x2afb, 0x7076, 0x29ce, 0x7179, 0x289a,
    0x7274, 0x2760, 0x7368, 0x2620, 0x7453, 0x24da, 0x7537, 0x238e,
    0x7612, 0x223d, 0x76e5, 0x20e7, 0x77b0, 0x1f8c, 0x7871, 0x1e2b,
    0x792b, 0x1cc6, 0x79db, 0x1b5d, 0x7a82, 0x19ef, 0x7b21, 0x187e,
    0x7bb6, 0x1709, 0x7c42, 0x1590, 0x7cc5, 0x1413, 0x7d3f, 0x1294,
    0x7daf, 0x1112, 0x7e15, 0xf8d, 0x7e72, 0xe06, 0x7ec5, 0xc7c, 
    0x7f0f, 0xaf1, 0x7f4f, 0x964, 0x7f85, 0x7d6, 0x7fb1, 0x646, 
    0x7fd4, 0x4b5, 0x7fec, 0x324, 0x7ffb, 0x192, 0x7fff, 0x0, 
    0x7ffb, 0xfe6e, 0x7fec, 0xfcdc, 0x7fd4, 0xfb4b, 0x7fb1, 0xf9ba, 
    0x7f85, 0xf82a, 0x7f4f, 0xf69c, 0x7f0f, 0xf50f, 0x7ec5, 0xf384,
    0x7e72, 0xf1fa, 0x7e15, 0xf073, 0x7daf, 0xeeee, 0x7d3f, 0xed6c, 
    0x7cc5, 0xebed, 0x7c42, 0xea70, 0x7bb6, 0xe8f7, 0x7b21, 0xe782, 
    0x7a82, 0xe611, 0x79db, 0xe4a3, 0x792b, 0xe33a, 0x7871, 0xe1d5, 
    0x77b0, 0xe074, 0x76e5, 0xdf19, 0x7612, 0xddc3, 0x7537, 0xdc72, 
    0x7453, 0xdb26, 0x7368, 0xd9e0, 0x7274, 0xd8a0, 0x7179, 0xd766, 
    0x7076, 0xd632, 0x6f6c, 0xd505, 0x6e5a, 0xd3df, 0x6d41, 0xd2bf, 
    0x6c21, 0xd1a6, 0x6afb, 0xd094, 0x69ce, 0xcf8a, 0x689a, 0xce87, 
    0x6760, 0xcd8c, 0x6620, 0xcc98, 0x64da, 0xcbad, 0x638e, 0xcac9, 
    0x623d, 0xc9ee, 0x60e7, 0xc91b, 0x5f8c, 0xc850, 0x5e2b, 0xc78f, 
    0x5cc6, 0xc6d5, 0x5b5d, 0xc625, 0x59ef, 0xc57e, 0x587e, 0xc4df, 
    0x5709, 0xc44a, 0x5590, 0xc3be, 0x5413, 0xc33b, 0x5294, 0xc2c1, 
    0x5112, 0xc251, 0x4f8d, 0xc1eb, 0x4e06, 0xc18e, 0x4c7c, 0xc13b, 
    0x4af1, 0xc0f1, 0x4964, 0xc0b1, 0x47d6, 0xc07b, 0x4646, 0xc04f, 
    0x44b5, 0xc02c, 0x4324, 0xc014, 0x4192, 0xc005
};

static inline uint32_t __QADD16(uint32_t op1, uint32_t op2) {
  uint32_t result;
  __asm volatile ("qadd16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
  return(result);
}

static inline uint32_t __QASX(uint32_t op1, uint32_t op2) {
  uint32_t result;
  __asm volatile ("qasx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
  return(result);
}

static inline uint32_t __QSAX(uint32_t op1, uint32_t op2) {
  uint32_t result;
  __asm volatile ("qsax %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
  return(result);
}

static inline uint32_t __QSUB16(uint32_t op1, uint32_t op2) {
  uint32_t result;
  __asm volatile ("qsub16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
  return(result);
}

static inline uint32_t __SHADD16(uint32_t op1, uint32_t op2) {
  uint32_t result;
  __asm volatile ("shadd16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
  return(result);
}

static inline uint32_t __SHASX(uint32_t op1, uint32_t op2) {
  uint32_t result;
  __asm volatile ("shasx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
  return(result);
}

static inline uint32_t __SHSAX(uint32_t op1, uint32_t op2) {
  uint32_t result;
  __asm volatile ("shsax %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
  return(result);
}

static inline uint32_t __SHSUB16(uint32_t op1, uint32_t op2) {
  uint32_t result;
  __asm volatile ("shsub16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
  return(result);
}

static inline uint32_t __SMLAD(uint32_t op1, uint32_t op2, uint32_t op3) {
  uint32_t result;
  __asm volatile ("smlad %0, %1, %2, %3" : "=r" (result) : "r" (op1), "r" (op2), "r" (op3) );
  return(result);
}

static inline uint32_t __SMLADX(uint32_t op1, uint32_t op2, uint32_t op3) {
  uint32_t result;
  __asm volatile ("smladx %0, %1, %2, %3" : "=r" (result) : "r" (op1), "r" (op2), "r" (op3) );
  return(result);
}

static inline uint32_t __SMUAD(uint32_t op1, uint32_t op2) {
  uint32_t result;
  __asm volatile ("smuad %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
  return(result);
}

static inline uint32_t __SMUSD(uint32_t op1, uint32_t op2) {
  uint32_t result;
  __asm volatile ("smusd %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
  return(result);
}

static inline uint32_t __SMUSDX(uint32_t op1, uint32_t op2) {
  uint32_t result;
  __asm volatile ("smusdx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
  return(result);
}
