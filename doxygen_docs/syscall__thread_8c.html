<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>14642 Lab3: kernel/src/syscall_thread.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">14642 Lab3
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part --><!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_dc43877d82dd332f9fb2071fcca799d6.html">kernel</a></li><li class="navelem"><a class="el" href="dir_3dd30a497388ee684638f120a124721c.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">syscall_thread.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>thread syscall implementation for lab 4  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;<a class="el" href="arm_8h_source.html">arm.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="mpu_8h_source.html">mpu.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="printk_8h_source.html">printk.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="syscall_8h_source.html">syscall.h</a>&gt;</code><br />
<code>#include &lt;syscall_mutex.h&gt;</code><br />
<code>#include &lt;<a class="el" href="syscall__thread_8h_source.html">syscall_thread.h</a>&gt;</code><br />
<code>#include &lt;unistd.h&gt;</code><br />
<code>#include &lt;<a class="el" href="timer_8h_source.html">timer.h</a>&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for syscall_thread.c:</div>
<div class="dyncontent">
<div class="center"><img src="syscall__thread_8c__incl.png" border="0" usemap="#kernel_2src_2syscall__thread_8c" alt=""/></div>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a3c88edc8d48ce7172e288f14dd6a06d6"><td class="memItemLeft" align="right" valign="top"><a id="a3c88edc8d48ce7172e288f14dd6a06d6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a3c88edc8d48ce7172e288f14dd6a06d6">XPSR_INIT</a>&#160;&#160;&#160;0x1000000</td></tr>
<tr class="memdesc:a3c88edc8d48ce7172e288f14dd6a06d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initial XPSR value, all 0s except thumb bit. <br /></td></tr>
<tr class="separator:a3c88edc8d48ce7172e288f14dd6a06d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a6ea3d12a6db3f3a0b8afcb52881c2a"><td class="memItemLeft" align="right" valign="top"><a id="a8a6ea3d12a6db3f3a0b8afcb52881c2a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a8a6ea3d12a6db3f3a0b8afcb52881c2a">LR_RETURN_TO_USER_PSP</a>&#160;&#160;&#160;0xFFFFFFFD</td></tr>
<tr class="memdesc:a8a6ea3d12a6db3f3a0b8afcb52881c2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return code to return to user mode with user stack. <br /></td></tr>
<tr class="separator:a8a6ea3d12a6db3f3a0b8afcb52881c2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a84de83d8cbea30290aab3c7eee772049"><td class="memItemLeft" align="right" valign="top"><a id="a84de83d8cbea30290aab3c7eee772049"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>default_idle</b> ()</td></tr>
<tr class="separator:a84de83d8cbea30290aab3c7eee772049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1537121ca74436338438808e1bed52ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a1537121ca74436338438808e1bed52ba">tcb_init</a> (tcb_t *<a class="el" href="structtcb.html">tcb</a>, void *fn, void *vargp, uint32_t priority, uint32_t C, uint32_t T)</td></tr>
<tr class="memdesc:a1537121ca74436338438808e1bed52ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">We maintain a linked list of all the TCBs. This function is used to initialise the linked list of the TCBs. It takes in the same paramters as sys_thread create and then assigns it to the individual fields in the TCB.  <a href="syscall__thread_8c.html#a1537121ca74436338438808e1bed52ba">More...</a><br /></td></tr>
<tr class="separator:a1537121ca74436338438808e1bed52ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9849c5888decb018dda3c1c25ca57778"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a9849c5888decb018dda3c1c25ca57778">append_tcb_list</a> (tcb_t **start, tcb_t *new_tcb)</td></tr>
<tr class="separator:a9849c5888decb018dda3c1c25ca57778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adef5907537cad2cc81876367ab76985d"><td class="memItemLeft" align="right" valign="top">tcb_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#adef5907537cad2cc81876367ab76985d">get_first_tcb</a> (tcb_t **start)</td></tr>
<tr class="memdesc:adef5907537cad2cc81876367ab76985d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the function that is used to get the first free tcb from the linked list of TCBs. It takes in a pointer to the tcb which needs to be deleted.  <a href="syscall__thread_8c.html#adef5907537cad2cc81876367ab76985d">More...</a><br /></td></tr>
<tr class="separator:adef5907537cad2cc81876367ab76985d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae84a936d083ddd7b86e85beff2a4db91"><td class="memItemLeft" align="right" valign="top"><a id="ae84a936d083ddd7b86e85beff2a4db91"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>thread_kill_working</b> ()</td></tr>
<tr class="separator:ae84a936d083ddd7b86e85beff2a4db91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfa46dd49fd5987b3366311d71ccea97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#adfa46dd49fd5987b3366311d71ccea97">default_idle_helper</a> ()</td></tr>
<tr class="memdesc:adfa46dd49fd5987b3366311d71ccea97"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the default idle thread function which acts as a helper to call the wait_for_interrupt function. When no threads remain in the system, then this idle thread is scheduled to run.  <a href="syscall__thread_8c.html#adfa46dd49fd5987b3366311d71ccea97">More...</a><br /></td></tr>
<tr class="separator:adfa46dd49fd5987b3366311d71ccea97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc96a6564aa346ba124293a6604a0427"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#abc96a6564aa346ba124293a6604a0427">systick_c_handler</a> ()</td></tr>
<tr class="memdesc:abc96a6564aa346ba124293a6604a0427"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to handle the interrupts which are generated by the systick timer We perform the necessary state changes and then pend the pend SV which will take care of the scheduling of the threads.  <a href="syscall__thread_8c.html#abc96a6564aa346ba124293a6604a0427">More...</a><br /></td></tr>
<tr class="separator:abc96a6564aa346ba124293a6604a0427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3804439769e7e553283b916886c5b67d"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a3804439769e7e553283b916886c5b67d">pendsv_c_handler</a> (void *msp)</td></tr>
<tr class="separator:a3804439769e7e553283b916886c5b67d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a701d36ddf8a4453531a483f1d30039a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a701d36ddf8a4453531a483f1d30039a6">append_mutex_list</a> (<a class="el" href="structkmutex__t.html">kmutex_t</a> **start, <a class="el" href="structkmutex__t.html">kmutex_t</a> *new_mutex)</td></tr>
<tr class="memdesc:a701d36ddf8a4453531a483f1d30039a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to append an new mutex into the linked list of mutexes. It takes in a pointer to the start of the list and also a pointer to the new mutex which must be added into the linked list.  <a href="syscall__thread_8c.html#a701d36ddf8a4453531a483f1d30039a6">More...</a><br /></td></tr>
<tr class="separator:a701d36ddf8a4453531a483f1d30039a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a689c07bae118be3785d7e77a6be650a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a689c07bae118be3785d7e77a6be650a7">delete_tcb</a> (tcb_t **start, tcb_t *del_tcb)</td></tr>
<tr class="memdesc:a689c07bae118be3785d7e77a6be650a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to delete a tcb from the linked list of the TCBs. It also takes a pointer to the tcb which has to be deleted from the linked list.  <a href="syscall__thread_8c.html#a689c07bae118be3785d7e77a6be650a7">More...</a><br /></td></tr>
<tr class="separator:a689c07bae118be3785d7e77a6be650a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea445bd05f7a8c4617563bffaa6aea32"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#aea445bd05f7a8c4617563bffaa6aea32">delete_mutex</a> (<a class="el" href="structkmutex__t.html">kmutex_t</a> **start, <a class="el" href="structkmutex__t.html">kmutex_t</a> *del_mutex)</td></tr>
<tr class="memdesc:aea445bd05f7a8c4617563bffaa6aea32"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to delete a mutex from the linked list of the mutexes. It also takes a pointer to the mutex which has to be deleted from the linked list.  <a href="syscall__thread_8c.html#aea445bd05f7a8c4617563bffaa6aea32">More...</a><br /></td></tr>
<tr class="separator:aea445bd05f7a8c4617563bffaa6aea32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a882e42d90dca0d45c9c942f21ea5a457"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structkmutex__t.html">kmutex_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a882e42d90dca0d45c9c942f21ea5a457">get_first_mutex</a> (<a class="el" href="structkmutex__t.html">kmutex_t</a> **start)</td></tr>
<tr class="memdesc:a882e42d90dca0d45c9c942f21ea5a457"><td class="mdescLeft">&#160;</td><td class="mdescRight">We maintain a free list of mutexes. This function loops through the free list and returns the next free mutex.  <a href="syscall__thread_8c.html#a882e42d90dca0d45c9c942f21ea5a457">More...</a><br /></td></tr>
<tr class="separator:a882e42d90dca0d45c9c942f21ea5a457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af16ecd7af8c1a175f265597240e6b98b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#af16ecd7af8c1a175f265597240e6b98b">sys_thread_init</a> (uint32_t max_threads, uint32_t stack_size, void *idle_fn, <a class="el" href="mpu_8h.html#a9981a4d7a6ee4804657e50e0741eb78b">mpu_mode</a> memory_protection, uint32_t user_max_mutexes)</td></tr>
<tr class="memdesc:af16ecd7af8c1a175f265597240e6b98b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the system call that is used to initialise the threads of the system. This takes in all the details from the user like maximum threads to be created, size of the stack for each thread, pointer to the idle function, mode of memory protection and the maximum mutexes needed.  <a href="syscall__thread_8c.html#af16ecd7af8c1a175f265597240e6b98b">More...</a><br /></td></tr>
<tr class="separator:af16ecd7af8c1a175f265597240e6b98b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7456217e2b43c86404a72acac2df684f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a7456217e2b43c86404a72acac2df684f">sys_thread_create</a> (void *fn, uint32_t priority, uint32_t C, uint32_t T, void *vargp)</td></tr>
<tr class="memdesc:a7456217e2b43c86404a72acac2df684f"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a new thread as specified, if UB allows  <a href="syscall__thread_8c.html#a7456217e2b43c86404a72acac2df684f">More...</a><br /></td></tr>
<tr class="separator:a7456217e2b43c86404a72acac2df684f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0726d2166701a485c555e6b7f7af3b60"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a0726d2166701a485c555e6b7f7af3b60">sys_scheduler_start</a> (uint32_t frequency)</td></tr>
<tr class="memdesc:a0726d2166701a485c555e6b7f7af3b60"><td class="mdescLeft">&#160;</td><td class="mdescRight">tell the kernel to start running threads using Systick  <a href="syscall__thread_8c.html#a0726d2166701a485c555e6b7f7af3b60">More...</a><br /></td></tr>
<tr class="separator:a0726d2166701a485c555e6b7f7af3b60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b4f86fe10ac2c90ce8158872aac7ce2"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a8b4f86fe10ac2c90ce8158872aac7ce2">sys_get_priority</a> ()</td></tr>
<tr class="memdesc:a8b4f86fe10ac2c90ce8158872aac7ce2"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the dynamic priority of the running thread  <a href="syscall__thread_8c.html#a8b4f86fe10ac2c90ce8158872aac7ce2">More...</a><br /></td></tr>
<tr class="separator:a8b4f86fe10ac2c90ce8158872aac7ce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a341334c885696457b6f66bb8acda5b22"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a341334c885696457b6f66bb8acda5b22">sys_get_time</a> ()</td></tr>
<tr class="memdesc:a341334c885696457b6f66bb8acda5b22"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the current time in ticks  <a href="syscall__thread_8c.html#a341334c885696457b6f66bb8acda5b22">More...</a><br /></td></tr>
<tr class="separator:a341334c885696457b6f66bb8acda5b22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8933e910725546aa9e052369db9cf81"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#aa8933e910725546aa9e052369db9cf81">sys_thread_time</a> ()</td></tr>
<tr class="memdesc:aa8933e910725546aa9e052369db9cf81"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the total elapsed time for the running thread  <a href="syscall__thread_8c.html#aa8933e910725546aa9e052369db9cf81">More...</a><br /></td></tr>
<tr class="separator:aa8933e910725546aa9e052369db9cf81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a601e5d8e922ccdec535527e8d8724d78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a601e5d8e922ccdec535527e8d8724d78">sys_thread_kill</a> ()</td></tr>
<tr class="memdesc:a601e5d8e922ccdec535527e8d8724d78"><td class="mdescLeft">&#160;</td><td class="mdescRight">kill the running thread  <a href="syscall__thread_8c.html#a601e5d8e922ccdec535527e8d8724d78">More...</a><br /></td></tr>
<tr class="separator:a601e5d8e922ccdec535527e8d8724d78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a3a3fb472158a93e59df836b9935b54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a2a3a3fb472158a93e59df836b9935b54">sys_wait_until_next_period</a> ()</td></tr>
<tr class="memdesc:a2a3a3fb472158a93e59df836b9935b54"><td class="mdescLeft">&#160;</td><td class="mdescRight">deschedule thread and wait until next turn  <a href="syscall__thread_8c.html#a2a3a3fb472158a93e59df836b9935b54">More...</a><br /></td></tr>
<tr class="separator:a2a3a3fb472158a93e59df836b9935b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12d3058e8c4464d614c9506562710e91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structkmutex__t.html">kmutex_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a12d3058e8c4464d614c9506562710e91">sys_mutex_init</a> (uint32_t max_prio)</td></tr>
<tr class="memdesc:a12d3058e8c4464d614c9506562710e91"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to initialise mutex in the system. It accepts the max prio ceiling of the thread that will be using it. The kernel will not be doing any kind of checking in this function.  <a href="syscall__thread_8c.html#a12d3058e8c4464d614c9506562710e91">More...</a><br /></td></tr>
<tr class="separator:a12d3058e8c4464d614c9506562710e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a14ccbc1e43d61617b97ecd06cf65b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a6a14ccbc1e43d61617b97ecd06cf65b9">sys_mutex_lock</a> (<a class="el" href="structkmutex__t.html">kmutex_t</a> *mutex)</td></tr>
<tr class="memdesc:a6a14ccbc1e43d61617b97ecd06cf65b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">this function is used to lock a mutex when a thread has to execute a critical section.  <a href="syscall__thread_8c.html#a6a14ccbc1e43d61617b97ecd06cf65b9">More...</a><br /></td></tr>
<tr class="separator:a6a14ccbc1e43d61617b97ecd06cf65b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55db4294dd5ed35ee5b2b1b1043ddbdd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a55db4294dd5ed35ee5b2b1b1043ddbdd">sys_mutex_unlock</a> (<a class="el" href="structkmutex__t.html">kmutex_t</a> *mutex)</td></tr>
<tr class="memdesc:a55db4294dd5ed35ee5b2b1b1043ddbdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">this function is used to unlock a mutex when a thread is done executing a critical section.  <a href="syscall__thread_8c.html#a55db4294dd5ed35ee5b2b1b1043ddbdd">More...</a><br /></td></tr>
<tr class="separator:a55db4294dd5ed35ee5b2b1b1043ddbdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade54b96979ce37c7792611e41da21393"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#ade54b96979ce37c7792611e41da21393">RMS</a> ()</td></tr>
<tr class="memdesc:ade54b96979ce37c7792611e41da21393"><td class="mdescLeft">&#160;</td><td class="mdescRight">RMS scheduler which is used to find the highest priority task based on the time period of each task.  <a href="syscall__thread_8c.html#ade54b96979ce37c7792611e41da21393">More...</a><br /></td></tr>
<tr class="separator:ade54b96979ce37c7792611e41da21393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f9b67ff91bfd07433ccc433e715e64e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a6f9b67ff91bfd07433ccc433e715e64e">UB_test_RMS</a> (uint32_t no_threads, uint32_t C, uint32_t T)</td></tr>
<tr class="memdesc:a6f9b67ff91bfd07433ccc433e715e64e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to perform the UB test and outputs whether the task set is schedulable or not.  <a href="syscall__thread_8c.html#a6f9b67ff91bfd07433ccc433e715e64e">More...</a><br /></td></tr>
<tr class="separator:a6f9b67ff91bfd07433ccc433e715e64e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ace9d48c2b9878c2bc74ce53535708b94"><td class="memItemLeft" align="right" valign="top"><a id="ace9d48c2b9878c2bc74ce53535708b94"></a>
uint32_t *&#160;</td><td class="memItemRight" valign="bottom"><b>__thread_k_stacks_base</b></td></tr>
<tr class="separator:ace9d48c2b9878c2bc74ce53535708b94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a861292702d7111840e783bb000d76d61"><td class="memItemLeft" align="right" valign="top"><a id="a861292702d7111840e783bb000d76d61"></a>
uint32_t *&#160;</td><td class="memItemRight" valign="bottom"><b>__thread_k_stacks_limit</b></td></tr>
<tr class="separator:a861292702d7111840e783bb000d76d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f231ae62c7b7b2ac822f5e990131096"><td class="memItemLeft" align="right" valign="top"><a id="a2f231ae62c7b7b2ac822f5e990131096"></a>
uint32_t *&#160;</td><td class="memItemRight" valign="bottom"><b>__thread_u_stacks_base</b></td></tr>
<tr class="separator:a2f231ae62c7b7b2ac822f5e990131096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0ff1d6b6e2b6382e4fb69b02dbb4d9d"><td class="memItemLeft" align="right" valign="top"><a id="ae0ff1d6b6e2b6382e4fb69b02dbb4d9d"></a>
uint32_t *&#160;</td><td class="memItemRight" valign="bottom"><b>__thread_u_stacks_limit</b></td></tr>
<tr class="separator:ae0ff1d6b6e2b6382e4fb69b02dbb4d9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a647aa30359d8a287e4383ee05ede22da"><td class="memItemLeft" align="right" valign="top"><a id="a647aa30359d8a287e4383ee05ede22da"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><b>__psp_stack_limit</b></td></tr>
<tr class="separator:a647aa30359d8a287e4383ee05ede22da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cfcacf464428c5e29106f93e3f16936"><td class="memItemLeft" align="right" valign="top"><a id="a0cfcacf464428c5e29106f93e3f16936"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><b>__msp_stack_limit</b></td></tr>
<tr class="separator:a0cfcacf464428c5e29106f93e3f16936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a187e79dd2a6a18d6bbbc4f2509eb668b"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a187e79dd2a6a18d6bbbc4f2509eb668b">ub_table</a> []</td></tr>
<tr class="memdesc:a187e79dd2a6a18d6bbbc4f2509eb668b"><td class="mdescLeft">&#160;</td><td class="mdescRight">thread stack region limits  <a href="syscall__thread_8c.html#a187e79dd2a6a18d6bbbc4f2509eb668b">More...</a><br /></td></tr>
<tr class="separator:a187e79dd2a6a18d6bbbc4f2509eb668b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7f9449c669741b59013b4a6a1f6c064"><td class="memItemLeft" align="right" valign="top"><a id="ad7f9449c669741b59013b4a6a1f6c064"></a>
tcb_t&#160;</td><td class="memItemRight" valign="bottom"><b>TCB</b> [16]</td></tr>
<tr class="separator:ad7f9449c669741b59013b4a6a1f6c064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86d4d9d0839b33fefcda981b631b9a25"><td class="memItemLeft" align="right" valign="top"><a id="a86d4d9d0839b33fefcda981b631b9a25"></a>
<a class="el" href="structkmutex__t.html">kmutex_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>MU</b> [32]</td></tr>
<tr class="separator:a86d4d9d0839b33fefcda981b631b9a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7e7bbde02f510800d0ce730b80719ef"><td class="memItemLeft" align="right" valign="top"><a id="ab7e7bbde02f510800d0ce730b80719ef"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>eachThread</b></td></tr>
<tr class="separator:ab7e7bbde02f510800d0ce730b80719ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27ff6cc088f4447b8d14ddfac3a6437c"><td class="memItemLeft" align="right" valign="top"><a id="a27ff6cc088f4447b8d14ddfac3a6437c"></a>
tcb_t *&#160;</td><td class="memItemRight" valign="bottom"><b>idle_tcb_pointers</b> [16] = {0}</td></tr>
<tr class="separator:a27ff6cc088f4447b8d14ddfac3a6437c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a134bc6e118fcc7c28872a0640a0d0f16"><td class="memItemLeft" align="right" valign="top"><a id="a134bc6e118fcc7c28872a0640a0d0f16"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>max_threads_from_user</b> = 0</td></tr>
<tr class="separator:a134bc6e118fcc7c28872a0640a0d0f16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04a0f6fafd874c8012766b04dd852cda"><td class="memItemLeft" align="right" valign="top"><a id="a04a0f6fafd874c8012766b04dd852cda"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>max_mutexes</b> = 0</td></tr>
<tr class="separator:a04a0f6fafd874c8012766b04dd852cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4deb0efd21e92604931a6b17c136921"><td class="memItemLeft" align="right" valign="top"><a id="af4deb0efd21e92604931a6b17c136921"></a>
volatile uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>currentRunningThreadID</b> = 0</td></tr>
<tr class="separator:af4deb0efd21e92604931a6b17c136921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c0a807d1f93daea6255998e109a3311"><td class="memItemLeft" align="right" valign="top"><a id="a5c0a807d1f93daea6255998e109a3311"></a>
volatile uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>nextThreadID</b> = 1</td></tr>
<tr class="separator:a5c0a807d1f93daea6255998e109a3311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25bab11ccea66c5eb08555d81c715cd8"><td class="memItemLeft" align="right" valign="top"><a id="a25bab11ccea66c5eb08555d81c715cd8"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>global_system_time</b> = 0</td></tr>
<tr class="separator:a25bab11ccea66c5eb08555d81c715cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dad0f58c7180d4d017ac1595dd76bff"><td class="memItemLeft" align="right" valign="top"><a id="a0dad0f58c7180d4d017ac1595dd76bff"></a>
volatile uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>available_mutexes</b></td></tr>
<tr class="separator:a0dad0f58c7180d4d017ac1595dd76bff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab076891114899c6e76bba957b1fe03c3"><td class="memItemLeft" align="right" valign="top"><a id="ab076891114899c6e76bba957b1fe03c3"></a>
tcb_t *&#160;</td><td class="memItemRight" valign="bottom"><b>free_tcb_list</b> = NULL</td></tr>
<tr class="separator:ab076891114899c6e76bba957b1fe03c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94fc6c3ce258263aae009a6a197b3004"><td class="memItemLeft" align="right" valign="top"><a id="a94fc6c3ce258263aae009a6a197b3004"></a>
<a class="el" href="structkmutex__t.html">kmutex_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>free_mutex_list</b></td></tr>
<tr class="separator:a94fc6c3ce258263aae009a6a197b3004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57de0de384bc1e74fc4152cd018e0f90"><td class="memItemLeft" align="right" valign="top"><a id="a57de0de384bc1e74fc4152cd018e0f90"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>kernel_mode_set</b> = 0</td></tr>
<tr class="separator:a57de0de384bc1e74fc4152cd018e0f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>thread syscall implementation for lab 4 </p>
<dl class="section note"><dt>Note</dt><dd>Not for public release, do not share</dd></dl>
<dl class="section date"><dt>Date</dt><dd>last modified 14 October 2022 </dd></dl>
<dl class="section author"><dt>Author</dt><dd>CMU 14-642 </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a701d36ddf8a4453531a483f1d30039a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a701d36ddf8a4453531a483f1d30039a6">&#9670;&nbsp;</a></span>append_mutex_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void append_mutex_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkmutex__t.html">kmutex_t</a> **&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structkmutex__t.html">kmutex_t</a> *&#160;</td>
          <td class="paramname"><em>new_mutex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to append an new mutex into the linked list of mutexes. It takes in a pointer to the start of the list and also a pointer to the new mutex which must be added into the linked list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pointer</td><td>to the start of the linked list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pointer</td><td>to the mutex which needs to be added into the list</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>does not return </dd></dl>

</div>
</div>
<a id="a9849c5888decb018dda3c1c25ca57778"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9849c5888decb018dda3c1c25ca57778">&#9670;&nbsp;</a></span>append_tcb_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void append_tcb_list </td>
          <td>(</td>
          <td class="paramtype">tcb_t **&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tcb_t *&#160;</td>
          <td class="paramname"><em>new_tcb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to append a new tcb into the linked list of TCBs that we maintain in our kernel. This takes in a pointer to the start of the linked list and a pointer to the new tcb which needs to be added.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>of the tcb linked list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pointer</td><td>to the new tcb</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>does not return </dd></dl>

</div>
</div>
<a id="adfa46dd49fd5987b3366311d71ccea97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfa46dd49fd5987b3366311d71ccea97">&#9670;&nbsp;</a></span>default_idle_helper()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void default_idle_helper </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the default idle thread function which acts as a helper to call the wait_for_interrupt function. When no threads remain in the system, then this idle thread is scheduled to run. </p>
<p>@params[in] none</p>
<dl class="section return"><dt>Returns</dt><dd>does not return </dd></dl>

</div>
</div>
<a id="aea445bd05f7a8c4617563bffaa6aea32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea445bd05f7a8c4617563bffaa6aea32">&#9670;&nbsp;</a></span>delete_mutex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void delete_mutex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkmutex__t.html">kmutex_t</a> **&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structkmutex__t.html">kmutex_t</a> *&#160;</td>
          <td class="paramname"><em>del_mutex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to delete a mutex from the linked list of the mutexes. It also takes a pointer to the mutex which has to be deleted from the linked list. </p>
<p>@params[in] pointer to the linked list from which the mutex has to be deleted @params[in] pointer to the mutex which has to be deleted from the linked list</p>
<dl class="section return"><dt>Returns</dt><dd>does not return </dd></dl>

</div>
</div>
<a id="a689c07bae118be3785d7e77a6be650a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a689c07bae118be3785d7e77a6be650a7">&#9670;&nbsp;</a></span>delete_tcb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void delete_tcb </td>
          <td>(</td>
          <td class="paramtype">tcb_t **&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tcb_t *&#160;</td>
          <td class="paramname"><em>del_tcb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to delete a tcb from the linked list of the TCBs. It also takes a pointer to the tcb which has to be deleted from the linked list. </p>
<p>@params[in] pointer to the linked list from which the tcb has to be deleted @params[in] pointer to the tcb which has to be deleted from the linked list</p>
<dl class="section return"><dt>Returns</dt><dd>does not return </dd></dl>

</div>
</div>
<a id="a882e42d90dca0d45c9c942f21ea5a457"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a882e42d90dca0d45c9c942f21ea5a457">&#9670;&nbsp;</a></span>get_first_mutex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structkmutex__t.html">kmutex_t</a>* get_first_mutex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkmutex__t.html">kmutex_t</a> **&#160;</td>
          <td class="paramname"><em>start</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>We maintain a free list of mutexes. This function loops through the free list and returns the next free mutex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Pointer</td><td>to the start of the linked list of mutexes from where we need to fetch the mutex from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the mutex which has been fetched from the linked list of the mutexes. </dd></dl>

</div>
</div>
<a id="adef5907537cad2cc81876367ab76985d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adef5907537cad2cc81876367ab76985d">&#9670;&nbsp;</a></span>get_first_tcb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tcb_t * get_first_tcb </td>
          <td>(</td>
          <td class="paramtype">tcb_t **&#160;</td>
          <td class="paramname"><em>start</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the function that is used to get the first free tcb from the linked list of TCBs. It takes in a pointer to the tcb which needs to be deleted. </p>
<p>@params[in] pointer to tcb which has to be deleted from the list</p>
<dl class="section return"><dt>Returns</dt><dd>returns a pointer to the tcb which has been fetched from the linked list </dd></dl>

</div>
</div>
<a id="a3804439769e7e553283b916886c5b67d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3804439769e7e553283b916886c5b67d">&#9670;&nbsp;</a></span>pendsv_c_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* pendsv_c_handler </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>msp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the pendsv C handler which is going to take care of scheduling the next highest prio thread ID in the system. This accepts a pointer to the msp of the task which is stored in the stack and it will be transferred into r0 in the asm handler before the control being passed into this very c handler. This does the necessary scheduling and then passes control back into the pend the pendsv asm handler.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pointer</td><td>to the msp</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>does not return </dd></dl>

</div>
</div>
<a id="ade54b96979ce37c7792611e41da21393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade54b96979ce37c7792611e41da21393">&#9670;&nbsp;</a></span>RMS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t RMS </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>RMS scheduler which is used to find the highest priority task based on the time period of each task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns the ID of the thread </dd></dl>

</div>
</div>
<a id="a8b4f86fe10ac2c90ce8158872aac7ce2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b4f86fe10ac2c90ce8158872aac7ce2">&#9670;&nbsp;</a></span>sys_get_priority()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sys_get_priority </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get the dynamic priority of the running thread </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">no</td><td>input paramters</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns the priority of the thread </dd></dl>

</div>
</div>
<a id="a341334c885696457b6f66bb8acda5b22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a341334c885696457b6f66bb8acda5b22">&#9670;&nbsp;</a></span>sys_get_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sys_get_time </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get the current time in ticks </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">no</td><td>input parameters</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>global system time which is mainted by the system </dd></dl>

</div>
</div>
<a id="a12d3058e8c4464d614c9506562710e91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12d3058e8c4464d614c9506562710e91">&#9670;&nbsp;</a></span>sys_mutex_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structkmutex__t.html">kmutex_t</a>* sys_mutex_init </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_prio</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to initialise mutex in the system. It accepts the max prio ceiling of the thread that will be using it. The kernel will not be doing any kind of checking in this function. </p>
<p>Used to create a mutex object. The mutex resides in kernel space. The user receives a handle to it. With memory protection, the user cannot modify it. However, tt can still be passed around and used with lock, unlock.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>max prio of the thread that will use the mutex</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the mutex on success and NULL on failure </dd></dl>

</div>
</div>
<a id="a6a14ccbc1e43d61617b97ecd06cf65b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a14ccbc1e43d61617b97ecd06cf65b9">&#9670;&nbsp;</a></span>sys_mutex_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sys_mutex_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkmutex__t.html">kmutex_t</a> *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>this function is used to lock a mutex when a thread has to execute a critical section. </p>
<p>Lock a mutex.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">takes</td><td>in a pointer to the mutex that the thread wants to lock</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>no return value </dd></dl>

</div>
</div>
<a id="a55db4294dd5ed35ee5b2b1b1043ddbdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55db4294dd5ed35ee5b2b1b1043ddbdd">&#9670;&nbsp;</a></span>sys_mutex_unlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sys_mutex_unlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkmutex__t.html">kmutex_t</a> *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>this function is used to unlock a mutex when a thread is done executing a critical section. </p>
<p>Unlock a mutex.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">takes</td><td>in a pointer to the mutex that the thread wants to unlock</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>no return value </dd></dl>

</div>
</div>
<a id="a0726d2166701a485c555e6b7f7af3b60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0726d2166701a485c555e6b7f7af3b60">&#9670;&nbsp;</a></span>sys_scheduler_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sys_scheduler_start </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>frequency</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>tell the kernel to start running threads using Systick </p>
<dl class="section note"><dt>Note</dt><dd>returns only after all threads complete or are killed</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frequency</td><td>frequncy of context switches in Hz</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success, -1 for failure </dd></dl>

</div>
</div>
<a id="a7456217e2b43c86404a72acac2df684f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7456217e2b43c86404a72acac2df684f">&#9670;&nbsp;</a></span>sys_thread_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sys_thread_create </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vargp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create a new thread as specified, if UB allows </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fn</td><td>thread function pointer </td></tr>
    <tr><td class="paramname">prio</td><td>thread priority, with 0 being highest </td></tr>
    <tr><td class="paramname">C</td><td>execution time (scheduler ticks) </td></tr>
    <tr><td class="paramname">T</td><td>task period (scheduler ticks) </td></tr>
    <tr><td class="paramname">vargp</td><td>thread function argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success, -1 for failure </dd></dl>

</div>
</div>
<a id="af16ecd7af8c1a175f265597240e6b98b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af16ecd7af8c1a175f265597240e6b98b">&#9670;&nbsp;</a></span>sys_thread_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sys_thread_init </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_threads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>stack_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>idle_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mpu_8h.html#a9981a4d7a6ee4804657e50e0741eb78b">mpu_mode</a>&#160;</td>
          <td class="paramname"><em>memory_protection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>user_max_mutexes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the system call that is used to initialise the threads of the system. This takes in all the details from the user like maximum threads to be created, size of the stack for each thread, pointer to the idle function, mode of memory protection and the maximum mutexes needed. </p>
<p>initialize thread switching</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">maximum</td><td>number of threads of the system </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stack</td><td>size for each thread </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pointer</td><td>to the idle function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">memory</td><td>protection - kernel only or per thread protection </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maximum</td><td>number of mutexes in the system</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 on failure and 0 on success </dd></dl>

</div>
</div>
<a id="a601e5d8e922ccdec535527e8d8724d78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a601e5d8e922ccdec535527e8d8724d78">&#9670;&nbsp;</a></span>sys_thread_kill()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sys_thread_kill </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>kill the running thread </p>
<dl class="section note"><dt>Note</dt><dd>locks if main or idle thread is running or thread holds a mutex</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>does not return </dd></dl>

</div>
</div>
<a id="aa8933e910725546aa9e052369db9cf81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8933e910725546aa9e052369db9cf81">&#9670;&nbsp;</a></span>sys_thread_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sys_thread_time </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get the total elapsed time for the running thread </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">no</td><td>input parameters</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value cumulative time that the thread has been executing </dd></dl>

</div>
</div>
<a id="a2a3a3fb472158a93e59df836b9935b54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a3a3fb472158a93e59df836b9935b54">&#9670;&nbsp;</a></span>sys_wait_until_next_period()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sys_wait_until_next_period </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>deschedule thread and wait until next turn </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">no</td><td>input parameters</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>no return value </dd></dl>

</div>
</div>
<a id="abc96a6564aa346ba124293a6604a0427"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc96a6564aa346ba124293a6604a0427">&#9670;&nbsp;</a></span>systick_c_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void systick_c_handler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to handle the interrupts which are generated by the systick timer We perform the necessary state changes and then pend the pend SV which will take care of the scheduling of the threads. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>does not return any value </dd></dl>

</div>
</div>
<a id="a1537121ca74436338438808e1bed52ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1537121ca74436338438808e1bed52ba">&#9670;&nbsp;</a></span>tcb_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcb_init </td>
          <td>(</td>
          <td class="paramtype">tcb_t *&#160;</td>
          <td class="paramname"><em>tcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vargp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>T</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>We maintain a linked list of all the TCBs. This function is used to initialise the linked list of the TCBs. It takes in the same paramters as sys_thread create and then assigns it to the individual fields in the TCB. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fn</td><td>thread function pointer </td></tr>
    <tr><td class="paramname">prio</td><td>thread priority, with 0 being highest </td></tr>
    <tr><td class="paramname">C</td><td>execution time (scheduler ticks) </td></tr>
    <tr><td class="paramname">T</td><td>task period (scheduler ticks) </td></tr>
    <tr><td class="paramname">vargp</td><td>thread function argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success, -1 for failure </dd></dl>

</div>
</div>
<a id="a6f9b67ff91bfd07433ccc433e715e64e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f9b67ff91bfd07433ccc433e715e64e">&#9670;&nbsp;</a></span>UB_test_RMS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int UB_test_RMS </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>no_threads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>T</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used to perform the UB test and outputs whether the task set is schedulable or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Number</td><td>of threads in the system currently (includes the new thread to be scheduled) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">WCET</td><td>of the task </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Time</td><td>period of the task </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a187e79dd2a6a18d6bbbc4f2509eb668b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a187e79dd2a6a18d6bbbc4f2509eb668b">&#9670;&nbsp;</a></span>ub_table</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float ub_table[]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    0.000, 1.000, .8284, .7798, .7568,</div>
<div class="line">     .7435, .7348, .7286, .7241, .7205,</div>
<div class="line">     .7177, .7155, .7136, .7119, .7106,</div>
<div class="line">     .7094, .7083, .7075, .7066, .7059,</div>
<div class="line">     .7052, .7047, .7042, .7037, .7033,</div>
<div class="line">     .7028, .7025, .7021, .7018, .7015,</div>
<div class="line">     .7012, .7009</div>
<div class="line">}</div>
</div><!-- fragment -->
<p>thread stack region limits </p>
<p>precomputed values for UB test </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
</div>
<hr class="footer"/><address class="footer"><small>
Generated by <a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>